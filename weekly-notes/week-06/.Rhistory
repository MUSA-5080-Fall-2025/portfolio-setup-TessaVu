# Define downtown Boston (Boston Common: 42.3551° N, 71.0656° W)
downtown <- st_sfc(st_point(c(-71.0656, 42.3551)), crs = "EPSG:4326") %>%
st_transform('ESRI:102286')
# Calculate distance from each house to downtown
boston.sf <- boston.sf %>%
mutate(
dist_downtown_ft = as.numeric(st_distance(geometry, downtown)),
dist_downtown_mi = dist_downtown_ft / 5280
)
# Summary
summary(boston.sf$dist_downtown_mi)
# Summary of all spatial features created
spatial_summary <- boston.sf %>%
st_drop_geometry() %>%
select(crimes.Buffer, crimes_500ft, crime_nn3, dist_downtown_mi) %>%
summary()
spatial_summary
boston.sf <- boston.sf %>%
mutate(Age = 2015 - YR_BUILT)
# Model 1: Structural only
model_structural <- lm(SalePrice ~ LivingArea + R_BDRMS + Age,
data = boston.sf)
# Model 2: Add spatial features
model_spatial <- lm(SalePrice ~ LivingArea + R_BDRMS + Age +
crimes_500ft + crime_nn3 + dist_downtown_mi,
data = boston.sf)
# Compare
cat("Structural R²:", round(summary(model_structural)$r.squared, 4), "\n")
cat("With spatial R²:", round(summary(model_spatial)$r.squared, 4), "\n")
cat("Improvement:", round(summary(model_spatial)$r.squared -
summary(model_structural)$r.squared, 4), "\n")
# Load packages and data
library(tidyverse)
library(sf)
library(here)
# Load Boston housing data
boston <- read_csv(here("data/boston.csv"))
# Quick look at the data
glimpse(boston)
# Simple model: Predict price from living area
# SalePrice is y (response) and LivingArea is x (predictor).
baseline_model <- lm(SalePrice ~ LivingArea, data = boston)
summary(baseline_model)
# Add number of bathrooms
better_model <- lm(SalePrice ~ LivingArea + R_FULL_BTH, data = boston)
summary(better_model)
# Compare models
cat("Baseline R²:", summary(baseline_model)$r.squared, "\n")
cat("With bathrooms R²:", summary(better_model)$r.squared, "\n")
# Convert boston data to sf object
boston.sf <- boston %>%
st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
st_transform('ESRI:102286')  # MA State Plane (feet)
# Check it worked
head(boston.sf)
class(boston.sf)  # Should show "sf" and "data.frame"
# Load neighborhood boundaries
nhoods <- read_sf(here("data/BPDA_Neighborhood_Boundaries.geojson")) %>%
st_transform('ESRI:102286')  # Match CRS!
# Check the neighborhoods
head(nhoods)
nrow(nhoods)  # How many neighborhoods?
# Spatial join: Assign each house to its neighborhood
boston.sf <- boston.sf %>%
st_join(nhoods, join = st_intersects)
# Check results
boston.sf %>%
st_drop_geometry() %>%
count(`name`) %>%
arrange(desc(n))
# Ensure name is a factor
boston.sf <- boston.sf %>%
mutate(name = as.factor(name))
# Check which is reference (first alphabetically)
levels(boston.sf$name)[1]
# Fit model with neighborhood fixed effects
model_neighborhoods <- lm(SalePrice ~ LivingArea + name,
data = boston.sf)
# Show just first 10 coefficients
summary(model_neighborhoods)$coef[1:10, ]
# Define wealthy neighborhoods based on median prices
wealthy_hoods <- c("Back Bay", "Beacon Hill", "South End", "Bay Village")
# Create binary indicator
boston.sf <- boston.sf %>%
mutate(
wealthy_neighborhood = ifelse(name %in% wealthy_hoods, "Wealthy", "Not Wealthy"),
wealthy_neighborhood = as.factor(wealthy_neighborhood)
)
# Check the split
boston.sf %>%
st_drop_geometry() %>%
count(wealthy_neighborhood)
# Model assumes same slope everywhere
model_no_interact <- lm(SalePrice ~ LivingArea + wealthy_neighborhood,
data = boston.sf)
summary(model_no_interact)$coef
# Model allows different slopes
model_interact <- lm(SalePrice ~ LivingArea * wealthy_neighborhood,
data = boston.sf)
summary(model_interact)$coef
# Compare R-squared
cat("Model WITHOUT interaction R²:", round(summary(model_no_interact)$r.squared, 4), "\n")
cat("Model WITH interaction R²:", round(summary(model_interact)$r.squared, 4), "\n")
cat("Improvement:", round(summary(model_interact)$r.squared - summary(model_no_interact)$r.squared, 4), "\n")
# Calculate age from year built
boston.sf <- boston.sf %>%
mutate(Age = 2025 - YR_BUILT)%>% filter(Age <2000)
# Check the distribution of age
summary(boston.sf$Age)
# Visualize age distribution
ggplot(boston.sf, aes(x = Age)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
labs(title = "Distribution of House Age in Boston",
x = "Age (years)",
y = "Count") +
theme_minimal()
# Simple linear relationship
model_age_linear <- lm(SalePrice ~ Age + LivingArea, data = boston.sf)
summary(model_age_linear)$coef
# Quadratic model (Age²)
model_age_quad <- lm(SalePrice ~ Age + I(Age^2) + LivingArea, data = boston.sf)
summary(model_age_quad)$coef
# R-squared comparison
r2_linear <- summary(model_age_linear)$r.squared
r2_quad <- summary(model_age_quad)$r.squared
cat("Linear model R²:", round(r2_linear, 4), "\n")
cat("Quadratic model R²:", round(r2_quad, 4), "\n")
cat("Improvement:", round(r2_quad - r2_linear, 4), "\n\n")
# F-test: Is the Age² term significant?
anova(model_age_linear, model_age_quad)
# Compare residual plots
par(mfrow = c(1, 2))
# Linear model residuals
plot(fitted(model_age_linear), residuals(model_age_linear),
main = "Linear Model Residuals",
xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, col = "red", lty = 2)
# Quadratic model residuals
plot(fitted(model_age_quad), residuals(model_age_quad),
main = "Quadratic Model Residuals",
xlab = "Fitted Values", ylab = "Residuals")
abline(h = 0, col = "red", lty = 2)
crimes.sf <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- st_transform(crimes.sf, 102286)
boston.sf <- st_transform(boston.sf, 102286)
# Create buffer features - these will work now that CRS is correct
boston.sf <- boston.sf %>%
mutate(
crimes.Buffer = lengths(st_intersects(
st_buffer(geometry, 660),
crimes.sf
)),
crimes_500ft = lengths(st_intersects(
st_buffer(geometry, 500),
crimes.sf
))
)
# Check it worked
ggplot(boston.sf, aes(x = crimes.Buffer)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
labs(title = "Distribution of House Age in Boston",
x = "Age (years)",
y = "Count") +
theme_minimal()
# Calculate distance matrix (houses to crimes)
dist_matrix <- st_distance(boston.sf, crimes.sf)
# Function to get mean distance to k nearest neighbors
get_knn_distance <- function(dist_matrix, k) {
apply(dist_matrix, 1, function(distances) {
# Sort and take first k, then average
mean(as.numeric(sort(distances)[1:k]))
})
}
# Create multiple kNN features
boston.sf <- boston.sf %>%
mutate(
crime_nn1 = get_knn_distance(dist_matrix, k = 1),
crime_nn3 = get_knn_distance(dist_matrix, k = 3),
crime_nn5 = get_knn_distance(dist_matrix, k = 5)
)
# Check results
summary(boston.sf %>% st_drop_geometry() %>% select(starts_with("crime_nn")))
# Which k value correlates most with price?
boston.sf %>%
st_drop_geometry() %>%
select(SalePrice, crime_nn1, crime_nn3, crime_nn5) %>%
cor(use = "complete.obs") %>%
as.data.frame() %>%
select(SalePrice)
# Define downtown Boston (Boston Common: 42.3551° N, 71.0656° W)
downtown <- st_sfc(st_point(c(-71.0656, 42.3551)), crs = "EPSG:4326") %>%
st_transform('ESRI:102286')
# Calculate distance from each house to downtown
boston.sf <- boston.sf %>%
mutate(
dist_downtown_ft = as.numeric(st_distance(geometry, downtown)),
dist_downtown_mi = dist_downtown_ft / 5280
)
# Summary
summary(boston.sf$dist_downtown_mi)
# Summary of all spatial features created
spatial_summary <- boston.sf %>%
st_drop_geometry() %>%
select(crimes.Buffer, crimes_500ft, crime_nn3, dist_downtown_mi) %>%
summary()
spatial_summary
boston.sf <- boston.sf %>%
mutate(Age = 2015 - YR_BUILT)
# Model 1: Structural only
model_structural <- lm(SalePrice ~ LivingArea + R_BDRMS + Age,
data = boston.sf)
# Model 2: Add spatial features
model_spatial <- lm(SalePrice ~ LivingArea + R_BDRMS + Age +
crimes_500ft + crime_nn3 + dist_downtown_mi,
data = boston.sf)
# Compare
cat("Structural R²:", round(summary(model_structural)$r.squared, 4), "\n")
cat("With spatial R²:", round(summary(model_spatial)$r.squared, 4), "\n")
cat("Improvement:", round(summary(model_spatial)$r.squared -
summary(model_structural)$r.squared, 4), "\n")
# Add neighborhood fixed effects
reg5 <- lm(
SalePrice ~ LivingArea + Age +
crimes_500ft +
parks_nn3 +
as.factor(name),  # FE
data = boston.sf
)
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
crimes.sf <- st_transform(crimes.sf, 102286)
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
neighborhood_boundaries <- st_transform(crimes.sf, 102286)
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
neighborhood_boundaries <- st_transform(neighborhood_boundaries, 102286)
boston.sf <- st_transform(boston.sf, 102286)
crimes.sf
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
neighborhood_boundaries <- st_transform(neighborhood_boundaries, 102286)
boston.sf <- st_transform(boston.sf, 102286)
# Create buffer features - these will work now that CRS is correct
boston.sf <- boston.sf %>%
mutate(
crimes.Buffer = lengths(st_intersects(
st_buffer(geometry, 660),
crimes.sf
)),
crimes_500ft = lengths(st_intersects(
st_buffer(geometry, 500),
crimes.sf
))
)
crimes.sf
neighborhood_boundaries
crimes.sf
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
neighborhood_boundaries <- st_transform(neighborhood_boundaries, 102286)
boston.sf <- st_transform(boston.sf, 102286)
crimes.sf <- st_as_sf(my_data, coords = c("Long", "Lat"), crs = 4326)
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
neighborhood_boundaries <- st_transform(neighborhood_boundaries, 102286)
boston.sf <- st_transform(boston.sf, 102286)
crimes.sf <- st_as_sf(crimes.sf, coords = c("Long", "Lat"), crs = 4326)
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
neighborhood_boundaries <- st_transform(neighborhood_boundaries, 102286)
boston.sf <- st_transform(boston.sf, 102286)
crimes.sf <- st_as_sf(crimes.sf, coords = c("Long", "Lat"), crs = 4326, na.rm = TRUE)
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
crimes.clean <- crimes.df %>%
filter(!is.na(Long) & !is.na(Lat))
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
crimes.sf <- crimes.sf %>%
filter(!is.na(Long) & !is.na(Lat))
neighborhood_boundaries <- st_transform(neighborhood_boundaries, 102286)
boston.sf <- st_transform(boston.sf, 102286)
crimes.sf <- st_as_sf(crimes.sf, coords = c("Long", "Lat"), crs = 4326)
crimes.sf <- st_transform(crimes.sf, 102286)
# Create buffer features - these will work now that CRS is correct
boston.sf <- boston.sf %>%
mutate(
crimes.Buffer = lengths(st_intersects(
st_buffer(geometry, 660),
crimes.sf
)),
crimes_500ft = lengths(st_intersects(
st_buffer(geometry, 500),
crimes.sf
))
)
# Check it worked
ggplot(boston.sf, aes(x = crimes.Buffer)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
labs(title = "Distribution of House Age in Boston",
x = "Age (years)",
y = "Count") +
theme_minimal()
neighborhood_boundaries <- st_read("data/BPDA_Neighborhood_Boundaries.geojson")
crimes.sf <- read_csv("data/bostonCrimes.csv")
crimes.sf <- crimes.sf %>%
na.omit()
neighborhood_boundaries <- st_transform(neighborhood_boundaries, 102286)
boston.sf <- st_transform(boston.sf, 102286)
crimes.sf <- st_as_sf(crimes.sf, coords = c("Long", "Lat"), crs = 4326)
crimes.sf <- st_transform(crimes.sf, 102286)
# Create buffer features - these will work now that CRS is correct
boston.sf <- boston.sf %>%
mutate(
crimes.Buffer = lengths(st_intersects(
st_buffer(geometry, 660),
crimes.sf
)),
crimes_500ft = lengths(st_intersects(
st_buffer(geometry, 500),
crimes.sf
))
)
# Check it worked
ggplot(boston.sf, aes(x = crimes.Buffer)) +
geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
labs(title = "Distribution of House Age in Boston",
x = "Age (years)",
y = "Count") +
theme_minimal()
# Create buffer features - these will work now that CRS is correct
boston.sf <- boston.sf %>%
mutate(
crimes.Buffer = lengths(st_intersects(
st_buffer(geometry, 660),
crimes.sf
)),
crimes_500ft = lengths(st_intersects(
st_buffer(geometry, 500),
crimes.sf
))
)
# Calculate distance matrix (houses to crimes)
dist_matrix <- st_distance(boston.sf, crimes.sf)
# Function to get mean distance to k nearest neighbors
get_knn_distance <- function(dist_matrix, k) {
apply(dist_matrix, 1, function(distances) {
# Sort and take first k, then average
mean(as.numeric(sort(distances)[1:k]))
})
}
# Create multiple kNN features
boston.sf <- boston.sf %>%
mutate(
crime_nn1 = get_knn_distance(dist_matrix, k = 1),
crime_nn3 = get_knn_distance(dist_matrix, k = 3),
crime_nn5 = get_knn_distance(dist_matrix, k = 5)
)
# Check results
summary(boston.sf %>% st_drop_geometry() %>% select(starts_with("crime_nn")))
# Which k value correlates most with price?
boston.sf %>%
st_drop_geometry() %>%
select(SalePrice, crime_nn1, crime_nn3, crime_nn5) %>%
cor(use = "complete.obs") %>%
as.data.frame() %>%
select(SalePrice)
# Define downtown Boston (Boston Common: 42.3551° N, 71.0656° W)
downtown <- st_sfc(st_point(c(-71.0656, 42.3551)), crs = "EPSG:4326") %>%
st_transform('ESRI:102286')
# Calculate distance from each house to downtown
boston.sf <- boston.sf %>%
mutate(
dist_downtown_ft = as.numeric(st_distance(geometry, downtown)),
dist_downtown_mi = dist_downtown_ft / 5280
)
# Summary
summary(boston.sf$dist_downtown_mi)
# Summary of all spatial features created
spatial_summary <- boston.sf %>%
st_drop_geometry() %>%
select(crimes.Buffer, crimes_500ft, crime_nn3, dist_downtown_mi) %>%
summary()
spatial_summary
boston.sf <- boston.sf %>%
mutate(Age = 2015 - YR_BUILT)
# Model 1: Structural only
model_structural <- lm(SalePrice ~ LivingArea + R_BDRMS + Age,
data = boston.sf)
# Model 2: Add spatial features
model_spatial <- lm(SalePrice ~ LivingArea + R_BDRMS + Age +
crimes_500ft + crime_nn3 + dist_downtown_mi,
data = boston.sf)
# Compare
cat("Structural R²:", round(summary(model_structural)$r.squared, 4), "\n")
cat("With spatial R²:", round(summary(model_spatial)$r.squared, 4), "\n")
cat("Improvement:", round(summary(model_spatial)$r.squared -
summary(model_structural)$r.squared, 4), "\n")
# Add neighborhood fixed effects
reg5 <- lm(
SalePrice ~ LivingArea + Age +
crimes_500ft +
parks_nn3 +
as.factor(name),  # FE
data = boston.sf
)
# Model 3: Structural Only
reg3 <- lm(SalePrice ~ LivingArea + Age + R_FULL_BTH,
data = boston.sf)
# Model 4: Add Spatial Features
reg4 <- lm(SalePrice ~ LivingArea + Age + R_FULL_BTH +
crimes_500ft + crime_nn3+ dist_downtown_mi,
data = boston.sf)
boston.sf <- boston.sf %>%
st_join(nhoods, join = st_intersects)
# Model 5: Add Fixed Effects
reg5 <- lm(SalePrice ~ LivingArea + Age + R_FULL_BTH +
crimes_500ft + crime_nn3+ dist_downtown_mi +
as.factor(name),
data = boston.sf)
library(caret)
ctrl <- trainControl(
method = "cv",
number = 10  # 10-fold CV
)
model_cv <- train(
SalePrice ~ LivingArea + Age,
data = boston.sf,
method = "lm",
trControl = ctrl
)
library(caret)
ctrl <- trainControl(method = "cv", number = 10)
# Model 1: Structural
cv_m1 <- train(
SalePrice ~ LivingArea + Age + R_FULL_BTH,
data = boston.sf, method = "lm", trControl = ctrl
)
# Model 2: + Spatial
cv_m2 <- train(
SalePrice ~ LivingArea + Age + R_FULL_BTH + crimes_500ft + crime_nn3,
data = boston.sf, method = "lm", trControl = ctrl
)
# Model 3: + Fixed Effects (BUT WAIT - there's a (potential) problem!)
cv_m3 <- train(
SalePrice ~ LivingArea + Age + R_FULL_BTH + crimes_500ft + crime_nn3 +
as.factor(name),
data = boston.sf, method = "lm", trControl = ctrl
)
# ALWAYS run this before CV with categorical variables
category_check %
# ALWAYS run this before CV with categorical variables
category_check %>%
st_drop_geometry() %>%
count(name) %>%
arrange(n)
# 1. Check category sizes
boston.sf %>%
st_drop_geometry() %>%
count(name) %>%
arrange(n) %>%
print()
# Import relevant libraries.
library(dplyr)
library(ggplot2)
library(gridExtra)
library(knitr)
library(kableExtra)
library(sf)
library(tibble)
library(tidycensus)
library(tidyr)
library(tidyverse)
library(tigris)
# Read in necessary data.
# Property data.
properties <- read.csv("data/philly_properties.csv")
#View(properties)
# Set Census API key
census_api_key("3aaee31789e10b674a531e9f236c35d5394b19ed")
# Check data types of all columns.
print(sapply(properties, class))
# All variables are character strings, convert numeric character variables to numeric classes.
properties <- properties %>%
mutate(across(c(objectid, book_and_page, category_code, census_tract,
depth, exempt_building, exempt_building, exterior_condition,
fireplaces, frontage, garage_spaces, garage_type,
geographic_ward, homestead_exemption, house_extension,
house_number, interior_condition, mailing_zip, market_value,
number_of_bathrooms, number_of_bedrooms, number_of_rooms,
number_stories, off_street_open, parcel_number, sale_price,
street_code, taxable_building, taxable_land, total_area,
total_livable_area, unit, year_built, zip_code, pin,
building_code_new), as.numeric))
# Filter to residential properties and 2023-2024 sales.
# Note: Category code #1 is for residential. Sale prices of amounts like $1 or $0 kept because gifting and low transactions often occur within families.
residential_prop <- properties %>%
filter(.,
category_code == 1,
startsWith(sale_date, "2023") | startsWith(sale_date, "2024"))
# Make empty character column values NA.
residential_prop <- residential_prop %>%
mutate(across(where(is.character), ~na_if(., "")))
# Drop empty variables or variables not needed for model.
residential_prop <- residential_prop %>%
select(-c(assessment_date, beginning_point, book_and_page, cross_reference,
date_exterior_condition, house_extension, homestead_exemption,
house_number, mailing_address_1, mailing_address_2, mailing_care_of,
market_value_date, owner_1, owner_2, recording_date, registry_number,
street_code, street_designation, street_direction, site_type, suffix))
View(residential_prop)
