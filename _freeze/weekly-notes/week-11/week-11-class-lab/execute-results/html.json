{
  "hash": "ae55d3da133496668b54a9a9049c2617",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: SPACE-TIME PREDICTION OF BIKE SHARE DEMAND\nsubtitle: \"LAB & HOMEWORK\"\ndate: 2025-11-17\nauthor:\n  - name: Tess Vu\n    email:\n      - tessavu@proton.me\n      - tessavu@upenn.edu\n    corresponding: TRUE\naffiliation:\n  - name: University of Pennsylvania\n    department: Urban Spatial Analytics (MUSA)\n    city: Philadelphia\n    state: PA\n    url: https://www.design.upenn.edu/urban-spatial-analytics\nformat:\n  html:\n    code-fold: show\n    toc: true\n    toc_float: true\n    toc-expand: true\n    smooth-scroll: true\n    embed-resources: true\n    title-block-style: default\nexecute:\n  warning: false\n  message: false\n---\n\n## 1.1. Introduction\n\n\n\nOne of the big operational challenges of bike share systems is \"re-balancing\" - getting bikes to stations that are anticipated to have demand but lack bikes. Figuring out how to do this is one of the keys to operating a successful system. Your homework will give you the opportunity to use predictive modeling to operationalize intelligence in this use case.\n\nHere we will predict only the demand (ignoring the supply of bikes, network routing of rebalancing trucs etc.,), but it will give us a window into how we can use time-space predictive modeling to address an operations issue. If we knew the bike station capacities, we could see when demand for bikes might drive stations to run out of bikes, and then move excess bikes from elsewhere. A program manager for a bike-share system could reasonably anticipate demand and allocate bikes ahead of time.\n\nThe demand for parking spaces, uber trips, bike share, road access and a whole host of urban transportation phenomena are time and space dependent, and modeling them frequently involves simply controlling for the day, hour, location, weather and other temporal phenomena. Quite simply, the demand for bike share trips today at my location at 5PM is probably highly correlated with the demand last week at the same time. Predicting demand for bike share rides across Chicago is similar to predicting demand for ride-hailing services (which you will have done in class), except the stations are fixed.\n\nThe expectation with this tutorial is that you can work through it without running the code and instead focus on the discussion. The code itself is there if you want to try it out - but it's probably best left alone until you use it (and or similar code from the book) for the homework.\n\nOne important note - some of the `purrr` functions (such as `unnest`) vary from build to build, so you may get warning messages. As with everything open source, you may find versioning issues - if something doesn't work correctly, check the code in the textbook for rideshare prediction and swap some of that out instead.\n\nYou can also (if you choose) load an R Workspace which represents the output of all the code in the document. There is a link to that workspace on the class Piazza page in the Resources section.\n\n**Objectives**\n\n**1. Discuss time-space trends in bike share data through exploratory analysis. What are the factors that affect whether somebody takes a bike share trip? How do we paramaterize and predict this?**\n\n**2. Learn how to create panel (timeseries) data and time lag variables. Understand the structure of panel data.**\n\n**3. Create multiple models *at the same time* using `purrr` and a nested data structure.**\n\n**4. Evaluate models and their errors in time and space.**\n\n## 2.1. Setup\n\nLet's load relevant libraries and some graphic themes. Note that my preference is to use `plotTheme` and `mapTheme` etc., as an object, not a function. This differs from Ken's routines.\n\n### 2025 fix. The goverment broke the census website so here's a fix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(RSocrata)\nlibrary(devtools)\nlibrary(tigris)\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(lubridate)\nlibrary(tigris)\nlibrary(tidycensus)\nlibrary(viridis)\nlibrary(riem)\nlibrary(gridExtra)\nlibrary(knitr)\nlibrary(kableExtra)\n\nplotTheme <- theme(\n  plot.title =element_text(size=12),\n  plot.subtitle = element_text(size=8),\n  plot.caption = element_text(size = 6),\n  axis.text.x = element_text(size = 10, angle = 45, hjust = 1),\n  axis.text.y = element_text(size = 10),\n  axis.title.y = element_text(size = 10),\n  # Set the entire chart region to blank\n  panel.background=element_blank(),\n  plot.background=element_blank(),\n  #panel.border=element_rect(colour=\"#F0F0F0\"),\n  # Format the grid\n  panel.grid.major=element_line(colour=\"#D0D0D0\",size=.2),\n  axis.ticks=element_blank())\n\nmapTheme <- theme(plot.title =element_text(size=12),\n                  plot.subtitle = element_text(size=8),\n                  plot.caption = element_text(size = 6),\n                  axis.line=element_blank(),\n                  axis.text.x=element_blank(),\n                  axis.text.y=element_blank(),\n                  axis.ticks=element_blank(),\n                  axis.title.x=element_blank(),\n                  axis.title.y=element_blank(),\n                  panel.background=element_blank(),\n                  panel.border=element_blank(),\n                  panel.grid.major=element_line(colour = 'transparent'),\n                  panel.grid.minor=element_blank(),\n                  legend.direction = \"vertical\", \n                  legend.position = \"right\",\n                  plot.margin = margin(1, 1, 1, 1, 'cm'),\n                  legend.key.height = unit(1, \"cm\"), legend.key.width = unit(0.2, \"cm\"))\n\npalette5 <- c(\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\")\npalette4 <- c(\"#D2FBD4\",\"#92BCAB\",\"#527D82\",\"#123F5A\")\npalette2 <- c(\"#6baed6\",\"#08519c\")\n```\n:::\n\n\nLoad your census API key so we can grab stuff from `tidycensus`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install Census API Key\n# census_api_key(\"YOUR KEY GOES HERE\", overwrite = TRUE)\n```\n:::\n\n\n## 2.2. Import Data\n\nLet's read in the month of May, 2018 using `read.socrata` and a SQL query. The weather in Chicago is notoriously awful for much of the year, but May has a fairly pleasant temperature range, so we may see some leisure trips as well as commutes. It contains one major holiday weekend, Memorial Day.\n\n**Take a closer look at the `read.socrata` call and see where there are dates and times in the SQL code.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install from GitHub\n# install.packages(\"devtools\")\n#devtools::install_github(\"Chicago/RSocrata\")\n\n#dat <- read.socrata(\"https://data.cityofchicago.org/resource/fg6s-gzvg.csv?$where=start_time%20between%20%272018-05-1T12:00:00%27%20and%20%272018-05-31T14:00:00%27\")\n\n# Save for R data types\n#saveRDS(dat, \"data/chicago_bikeshare.rds\")\n\n# Load\ndat <- readRDS(\"data/chicago_bikeshare.rds\")\n```\n:::\n\n\nWe can take a look at our data to see the format and names of all of our columns using the `glimpse` command.\n\n\n::: {.cell}\n\n:::\n\n\nLet's use some date parsing to bin\" the data by 15 and 60 minute intervals by rounding. \n\nNotice we use the time format `ymd_hms` to denote year, month, day and hour, minute and seccond. We extract the `week` of the observation (ranging from 1-52 throughout the year) and the `dotw` for day of the week.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat2 <- dat %>%\n  mutate(interval60 = floor_date(ymd_hms(start_time), unit = \"hour\"),\n         interval15 = floor_date(ymd_hms(start_time), unit = \"15 mins\"),\n         week = week(interval60),\n         dotw = wday(interval60, label=TRUE))\n\nglimpse(dat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 385,176\nColumns: 22\n$ trip_id           <int> 18368862, 18368861, 18368860, 18368859, 18368858, 18…\n$ start_time        <dttm> 2018-05-09 07:31:05, 2018-05-09 07:30:57, 2018-05-0…\n$ stop_time         <dttm> 2018-05-09 07:44:52, 2018-05-09 07:41:00, 2018-05-0…\n$ bike_id           <int> 2021, 2696, 3379, 4738, 3272, 2830, 1001, 6411, 6308…\n$ trip_duration     <int> 827, 603, 1184, 996, 709, 426, 683, 683, 472, 177, 2…\n$ from_station_id   <int> 50, 92, 144, 118, 60, 394, 29, 172, 24, 16, 191, 482…\n$ from_station_name <chr> \"Clark St & Congress Pkwy\", \"Carpenter St & Huron St…\n$ to_station_id     <int> 199, 30, 43, 52, 161, 287, 91, 37, 49, 58, 283, 295,…\n$ to_station_name   <chr> \"Wabash Ave & Grand Ave\", \"Ashland Ave & Augusta Blv…\n$ user_type         <chr> \"Subscriber\", \"Subscriber\", \"Subscriber\", \"Subscribe…\n$ gender            <chr> \"Female\", \"Male\", \"Male\", \"Male\", \"Male\", \"Male\", \"M…\n$ birth_year        <int> 1953, 1997, 1962, 1994, 1961, 1988, 1989, 1960, 1990…\n$ from_latitude     <dbl> 41.87593, 41.89456, 41.92182, 41.91139, 41.91058, 41…\n$ from_longitude    <dbl> -87.63058, -87.65345, -87.64414, -87.63868, -87.6494…\n$ from_location     <chr> \"POINT (-87.6305845355 41.8759326655)\", \"POINT (-87.…\n$ to_latitude       <dbl> 41.89147, 41.89964, 41.88389, 41.88602, 41.89576, 41…\n$ to_longitude      <dbl> -87.62676, -87.66770, -87.62465, -87.62412, -87.6259…\n$ to_location       <chr> \"POINT (-87.626761 41.891466)\", \"POINT (-87.6677 41.…\n$ interval60        <dttm> 2018-05-09 07:00:00, 2018-05-09 07:00:00, 2018-05-0…\n$ interval15        <dttm> 2018-05-09 07:30:00, 2018-05-09 07:30:00, 2018-05-0…\n$ week              <dbl> 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, …\n$ dotw              <ord> Wed, Wed, Wed, Wed, Wed, Wed, Wed, Wed, Wed, Wed, We…\n```\n\n\n:::\n:::\n\n\n## 2.3. Import Census Info\n\nUsing the `tidycensus` package, we can download census geography and variables. These are used to test generalizeability later, but *we don't use them as independent variables because they end up being perfectly collinear with the stations fixed effects*. We extract the tracts for mapping and joining purposes - creating an `sf` object that consists only of GEOIDs and geometries.\n\nWe add the spatial information to our rideshare data as origin and destination data, first joining the origin station, then the destination station to our census data. We don't use the destination data in this exercise, but it may come in handy if you want to try to understand the dynamics of your data in exploratory analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchicagoCensus <- \n  get_acs(geography = \"tract\", \n          variables = c(\"B01003_001\", \"B19013_001\", \n                        \"B02001_002\", \"B08013_001\",\n                        \"B08012_001\", \"B08301_001\", \n                        \"B08301_010\", \"B01002_001\"), \n          year = 2017, \n          state = \"IL\", \n          geometry = TRUE, \n          county=c(\"Cook\"),\n          output = \"wide\") %>%\n  rename(Total_Pop =  B01003_001E,\n         Med_Inc = B19013_001E,\n         Med_Age = B01002_001E,\n         White_Pop = B02001_002E,\n         Travel_Time = B08013_001E,\n         Num_Commuters = B08012_001E,\n         Means_of_Transport = B08301_001E,\n         Total_Public_Trans = B08301_010E) %>%\n  select(Total_Pop, Med_Inc, White_Pop, Travel_Time,\n         Means_of_Transport, Total_Public_Trans,\n         Med_Age,\n         GEOID, geometry) %>%\n  mutate(Percent_White = White_Pop / Total_Pop,\n         Mean_Commute_Time = Travel_Time / Total_Public_Trans,\n         Percent_Taking_Public_Trans = Total_Public_Trans / Means_of_Transport)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchicagoTracts <- \n  chicagoCensus %>%\n  as.data.frame() %>%\n  distinct(GEOID, .keep_all = TRUE) %>%\n  select(GEOID, geometry) %>% \n  st_sf\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_census <- st_join(dat2 %>% \n          filter(is.na(from_longitude) == FALSE &\n                   is.na(from_latitude) == FALSE &\n                   is.na(to_latitude) == FALSE &\n                   is.na(to_longitude) == FALSE) %>%\n          st_as_sf(., coords = c(\"from_longitude\", \"from_latitude\"), crs = 4326),\n        chicagoTracts %>%\n          st_transform(crs=4326),\n        join=st_intersects,\n              left = TRUE) %>%\n  rename(Origin.Tract = GEOID) %>%\n  mutate(from_longitude = unlist(map(geometry, 1)),\n         from_latitude = unlist(map(geometry, 2)))%>%\n  as.data.frame() %>%\n  select(-geometry)%>%\n  st_as_sf(., coords = c(\"to_longitude\", \"to_latitude\"), crs = 4326) %>%\n  st_join(., chicagoTracts %>%\n            st_transform(crs=4326),\n          join=st_intersects,\n          left = TRUE) %>%\n  rename(Destination.Tract = GEOID)  %>%\n  mutate(to_longitude = unlist(map(geometry, 1)),\n         to_latitude = unlist(map(geometry, 2)))%>%\n  as.data.frame() %>%\n  select(-geometry)\n```\n:::\n\n\n## 2.4. Import Weather Data\n\nImport weather data from O'Hare airport (code ORD) using `riem_measures`. We can `mutate` the data to get temperature, wind speed, precipitation on an hourly basis and plot the temperature and precipitation trends over our study period.\n\nThese data can also be categorized as a part of an exploration of the relationship between your independent and dependent variables, e.g. \"does wind appear to affect ridership during rush hour?\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather.Panel <- \n  riem_measures(station = \"ORD\", date_start = \"2018-05-01\", date_end = \"2018-05-31\") %>%\n  dplyr::select(valid, tmpf, p01i, sknt)%>%\n  replace(is.na(.), 0) %>%\n    mutate(interval60 = ymd_h(substr(valid,1,13))) %>%\n    mutate(week = week(interval60),\n           dotw = wday(interval60, label=TRUE)) %>%\n    group_by(interval60) %>%\n    summarize(Temperature = max(tmpf),\n              Precipitation = sum(p01i),\n              Wind_Speed = max(sknt)) %>%\n    mutate(Temperature = ifelse(Temperature == 0, 42, Temperature))\n\nglimpse(weather.Panel)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 716\nColumns: 4\n$ interval60    <dttm> 2018-05-01 00:00:00, 2018-05-01 01:00:00, 2018-05-01 02…\n$ Temperature   <dbl> 75, 72, 70, 68, 66, 65, 64, 65, 63, 61, 60, 61, 63, 68, …\n$ Precipitation <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ Wind_Speed    <dbl> 12, 13, 13, 15, 15, 12, 8, 12, 12, 8, 11, 11, 10, 10, 11…\n```\n\n\n:::\n:::\n\n\n\n::: {.cell catche='true'}\n\n```{.r .cell-code}\ngrid.arrange(\n  ggplot(weather.Panel, aes(interval60,Precipitation)) + geom_line() + \n  labs(title=\"Percipitation\", x=\"Hour\", y=\"Perecipitation\") + plotTheme,\n  ggplot(weather.Panel, aes(interval60,Wind_Speed)) + geom_line() + \n    labs(title=\"Wind Speed\", x=\"Hour\", y=\"Wind Speed\") + plotTheme,\n  ggplot(weather.Panel, aes(interval60,Temperature)) + geom_line() + \n    labs(title=\"Temperature\", x=\"Hour\", y=\"Temperature\") + plotTheme,\n  top=\"Weather Data - Chicago ORD - May, 2018\")\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/plot_weather-1.png){width=672}\n:::\n:::\n\n\n## 3.1. Describe and Explore the Data\n\nWe begin by examining the time and frequency components of our data.\n\nFirst, we look at the overall time pattern - there is clearly a daily periodicity and there are lull periods on weekends. Notice that the weekend near the 28th of May (Memorial Day) doesn't have the same dip in activity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dat_census %>%\n         group_by(interval60) %>%\n         tally())+\n  geom_line(aes(x = interval60, y = n))+\n  labs(title=\"Bike share trips per hr. Chicago, May, 2018\",\n       x=\"Date\", \n       y=\"Number of trips\")+\n  plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/trip_timeseries-1.png){width=672}\n:::\n:::\n\n\nLet's examine the distribution of trip volume by station for different times of the day. We clearly have a few high volume periods but mostly low volume. Our data must consist of a lot of low demand station/hours and a few high demand station hours. \n\nThere's a possibility we may have to treat these as count data here, which means running Poisson regression. Then again, we might have enough of the higher counts in our high volume times and stations, that we should really be building a linear model to accomodate our actual volume and not worry about the low trip times/stations.\n\nWe can also track the daily trends in ridership by day of the week and weekend versus weekday, to see what temporal patterns we'd like to control for.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_census %>%\n        mutate(time_of_day = case_when(hour(interval60) < 7 | hour(interval60) > 18 ~ \"Overnight\",\n                                 hour(interval60) >= 7 & hour(interval60) < 10 ~ \"AM Rush\",\n                                 hour(interval60) >= 10 & hour(interval60) < 15 ~ \"Mid-Day\",\n                                 hour(interval60) >= 15 & hour(interval60) <= 18 ~ \"PM Rush\"))%>%\n         group_by(interval60, from_station_name, time_of_day) %>%\n         tally()%>%\n  group_by(from_station_name, time_of_day)%>%\n  summarize(mean_trips = mean(n))%>%\n  ggplot()+\n  geom_histogram(aes(mean_trips), binwidth = 1)+\n  labs(title=\"Mean Number of Hourly Trips Per Station. Chicago, May, 2018\",\n       x=\"Number of trips\", \n       y=\"Frequency\")+\n  facet_wrap(~time_of_day)+\n  plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/mean_trips_hist-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dat_census %>%\n         group_by(interval60, from_station_name) %>%\n         tally())+\n  geom_histogram(aes(n), binwidth = 5)+\n  labs(title=\"Bike share trips per hr by station. Chicago, May, 2018\",\n       x=\"Trip Counts\", \n       y=\"Number of Stations\")+\n  plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/trips_station_dotw-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dat_census %>% mutate(hour = hour(start_time)))+\n     geom_freqpoly(aes(hour, color = dotw), binwidth = 1)+\n  labs(title=\"Bike share trips in Chicago, by day of the week, May, 2018\",\n       x=\"Hour\", \n       y=\"Trip Counts\")+\n     plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/trips_hour_dotw-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(dat_census %>% \n         mutate(hour = hour(start_time),\n                weekend = ifelse(dotw %in% c(\"Sun\", \"Sat\"), \"Weekend\", \"Weekday\")))+\n     geom_freqpoly(aes(hour, color = weekend), binwidth = 1)+\n  labs(title=\"Bike share trips in Chicago - weekend vs weekday, May, 2018\",\n       x=\"Hour\", \n       y=\"Trip Counts\")+\n     plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/trips_hour_dotw-2.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()+\n  geom_sf(data = chicagoTracts %>%\n          st_transform(crs=4326))+\n  geom_point(data = dat_census %>% \n            mutate(hour = hour(start_time),\n                weekend = ifelse(dotw %in% c(\"Sun\", \"Sat\"), \"Weekend\", \"Weekday\"),\n                time_of_day = case_when(hour(interval60) < 7 | hour(interval60) > 18 ~ \"Overnight\",\n                                 hour(interval60) >= 7 & hour(interval60) < 10 ~ \"AM Rush\",\n                                 hour(interval60) >= 10 & hour(interval60) < 15 ~ \"Mid-Day\",\n                                 hour(interval60) >= 15 & hour(interval60) <= 18 ~ \"PM Rush\"))%>%\n              group_by(from_station_id, from_latitude, from_longitude, weekend, time_of_day) %>%\n              tally(),\n            aes(x=from_longitude, y = from_latitude, color = n), \n            fill = \"transparent\", alpha = 0.4, size = 0.3)+\n  scale_colour_viridis(direction = -1,\n  discrete = FALSE, option = \"D\")+\n  ylim(min(dat_census$from_latitude), max(dat_census$from_latitude))+\n  xlim(min(dat_census$from_longitude), max(dat_census$from_longitude))+\n  facet_grid(weekend ~ time_of_day)+\n  labs(title=\"Bike share trips per hr by station. Chicago, May, 2018\")+\n  mapTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/origin_map-1.png){width=672}\n:::\n:::\n\n\n## 3.1 Create Space-Time Panel\n\nFirst **we have to make sure each unique station and hour/day combo exists in our data set.** This is done in order to create a \"panel\" (e.g. a time-series) data set where each time period in the study is represented by a row - whether an observation took place then or not. So if a station didn't have any trips originating from it at a given hour, we still need a zero in that spot in the panel.\n\nWe start by determining the maximum number of combinations.\n\nThen we compare that to the actual number of combinations. We create an empty data frame `study.panel`, is created that has each unique space/time observations. This is done using the expand.grid function and unique. Along the way, we keep tabs on the number of rows our data have - `nrow` shows that the count is still correct.\n\nWe then join the station name, tract and lat/lon (some have multiple lat lon info, so we just take the first one of each using `group_by` and `slice`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(unique(dat_census$interval60)) * length(unique(dat_census$from_station_id))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 410664\n```\n\n\n:::\n\n```{.r .cell-code}\nstudy.panel <- \n  expand.grid(interval60=unique(dat_census$interval60), \n              from_station_id = unique(dat_census$from_station_id)) %>%\n  left_join(., dat_census %>%\n              select(from_station_id, from_station_name, Origin.Tract, from_longitude, from_latitude )%>%\n              distinct() %>%\n              group_by(from_station_id) %>%\n              slice(1))\n\nnrow(study.panel)      \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 410664\n```\n\n\n:::\n:::\n\n\nWe create the full panel by summarizing counts by station for each time interval, keep census info and lat/lon information along for joining later to other data. We remove data for station IDs that are `FALSE`.\n\nWe also ditch a bit of data (this is why `study.panel` and `ride.panel` don't end up being exactly the same length). There are two stations - Dusable harbor and Eastlake Terrace that don't join properly to census tracts. They are too close to the water and don't play nice with our tracts. In the service of laziness, we get rid of these.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nride.panel <- \n  dat_census %>%\n  mutate(Trip_Counter = 1) %>%\n  right_join(study.panel) %>% \n  group_by(interval60, from_station_id, from_station_name, Origin.Tract, from_longitude, from_latitude) %>%\n  summarize(Trip_Count = sum(Trip_Counter, na.rm=T)) %>%\n  left_join(weather.Panel) %>%\n  ungroup() %>%\n  filter(is.na(from_station_id) == FALSE) %>%\n  mutate(week = week(interval60),\n         dotw = wday(interval60, label = TRUE)) %>%\n  filter(is.na(Origin.Tract) == FALSE)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nride.panel <- \n  left_join(ride.panel, chicagoCensus %>%\n              as.data.frame() %>%\n              select(-geometry), by = c(\"Origin.Tract\" = \"GEOID\"))\n```\n:::\n\n\n## 3.3. Create time lags\n\nCreating time lag variables will add additional nuance about the demand during a given time period - hours before and during that day. \n\nWe can also try to control for the effects of holidays that disrupt the expected demand during a given weekend or weekday. We have a holiday on May 28 - Memorial Day. For that three day weekend we could use some dummy variables indicating temporal proximity to the holiday.\n\nKeep in mind, that unique fixed effects must be in your training set when you run your models.\n\nWe can evaluate the correlations in these lags. They are pretty strong. There's a Pearson's R of 0.84 for the `lagHour` - that's very, very strong. \n\nThis makes a lot of intuitive sense - the demand right now should be relatively similar to the demand tomorrow at this time, and to the demand an hour from now, but twelve hours from now, we likely expect the opposite in terms of demand.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nride.panel <- \n  ride.panel %>% \n  arrange(from_station_id, interval60) %>% \n  mutate(lagHour = dplyr::lag(Trip_Count,1),\n         lag2Hours = dplyr::lag(Trip_Count,2),\n         lag3Hours = dplyr::lag(Trip_Count,3),\n         lag4Hours = dplyr::lag(Trip_Count,4),\n         lag12Hours = dplyr::lag(Trip_Count,12),\n         lag1day = dplyr::lag(Trip_Count,24),\n         holiday = ifelse(yday(interval60) == 148,1,0)) %>%\n   mutate(day = yday(interval60)) %>%\n   mutate(holidayLag = case_when(dplyr::lag(holiday, 1) == 1 ~ \"PlusOneDay\",\n                                 dplyr::lag(holiday, 2) == 1 ~ \"PlustTwoDays\",\n                                 dplyr::lag(holiday, 3) == 1 ~ \"PlustThreeDays\",\n                                 dplyr::lead(holiday, 1) == 1 ~ \"MinusOneDay\",\n                                 dplyr::lead(holiday, 2) == 1 ~ \"MinusTwoDays\",\n                                 dplyr::lead(holiday, 3) == 1 ~ \"MinusThreeDays\"),\n         holidayLag = ifelse(is.na(holidayLag) == TRUE, 0, holidayLag))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(ride.panel) %>%\n    group_by(interval60) %>% \n    summarise_at(vars(starts_with(\"lag\"), \"Trip_Count\"), mean, na.rm = TRUE) %>%\n    gather(Variable, Value, -interval60, -Trip_Count) %>%\n    mutate(Variable = factor(Variable, levels=c(\"lagHour\",\"lag2Hours\",\"lag3Hours\",\"lag4Hours\",\n                                                \"lag12Hours\",\"lag1day\")))%>%\n    group_by(Variable) %>%  \n    summarize(correlation = round(cor(Value, Trip_Count),2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  Variable   correlation\n  <fct>            <dbl>\n1 lagHour           0.84\n2 lag2Hours         0.57\n3 lag3Hours         0.36\n4 lag4Hours         0.22\n5 lag12Hours       -0.34\n6 lag1day           0.79\n```\n\n\n:::\n:::\n\n\n## 4.1. Run Models\n\nWe split our data into a training and a test set. We create five linear models using the `lm` funtion. Sometimes, for data such as these, Poisson distributions, designed for modeling counts, might be appropriate. I'll spare you the effort - linear models work better with this particular data set. \n\nWe create the models using our training data `ride.Train`. The first models include only temporal controls, but the later ones contain all of our lag information.\n\nNotice that we are using a partition that is user specified and is time dependent. \n\n**Why are we splitting our data by time and not randomly??**\n\n**Why are we using the end of the month to predict for the beginning of the month?**\n\nBe aware that these models may run quite slowly depending on how large your data set is and how many variables you decide to include.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nride.Train <- filter(ride.panel, week >= 20)\nride.Test <- filter(ride.panel, week < 20)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg1 <-\n  lm(Trip_Count ~  factor(hour(interval60)) + factor(dotw) + Temperature,  data=ride.Train)\n \nreg2 <-\n  lm(Trip_Count ~  from_station_name +  factor(dotw)+ Temperature,  data=ride.Train)\n \nreg3 <-\n  lm(Trip_Count ~  from_station_name + factor(hour(interval60)) + factor(dotw) + Temperature + Precipitation,\n     data=ride.Train)\n \nreg4 <-\n  lm(Trip_Count ~  from_station_name +  factor(hour(interval60)) +  factor(dotw) + Temperature + Precipitation +\n                   lagHour + lag2Hours +lag3Hours + lag12Hours + lag1day,\n     data=ride.Train)\n \nreg5 <-\n  lm(Trip_Count ~  from_station_name + factor(hour(interval60)) +  factor(dotw) + Temperature + Precipitation +\n                   lagHour + lag2Hours +lag3Hours +lag12Hours + lag1day + holidayLag + holiday,\n     data=ride.Train)\n```\n:::\n\n\n## 4.2. Predict for test data\n\nWhen your models have finished running, create a nested data frame of test data by week. Nested data is common in most other programming languages. For instance, the javascript object notation file format (aka JSON) is highly nested.\n\nNesting means that instead of merely having a \"flat\" file consisting of rows and columns, you have a matrix of other objects - imagine each cell in a matrix containing another matrix within it, or a list, or a list of lists. \n\nThe `purrr` package is designed to `map` functions through nested data structures. This concept is important - think of `map` as visiting each dataframe in a nested data set and applies a function to it.\n\nWe create a function called `model_pred` which we can then `map` onto each data frame in our nested structure.\n\nThis function is called in the code below in a few ways, one way is like so: `map(.x = data, fit = name_of_your_regression, .f = model_pred)`. Here's the important bit - the argument `fit` takes the name of a regression you have created that you want to use to make predictions, and the `.f` argument takes a function, in this case `model_pred`, which we create in order to simply execute the `predict` function.\n\nYou don't need to manipulate anything else in this code block other than the `fit` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nride.Test.weekNest <- \n  ride.Test %>%\n  nest(-week) \n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_pred <- function(dat, fit){\n   pred <- predict(fit, newdata = dat)}\n```\n:::\n\n\nWhen we run our predictions and summarize our results, we are going to have some NA data - recall we have some lag information that will necessarily trip up the model at the margins of the time frame. \n\n**We don't create a MAPE statistic here, why is that?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_predictions <- \n  ride.Test.weekNest %>% \n    mutate(ATime_FE = map(.x = data, fit = reg1, .f = model_pred),\n           BSpace_FE = map(.x = data, fit = reg2, .f = model_pred),\n           CTime_Space_FE = map(.x = data, fit = reg3, .f = model_pred),\n           DTime_Space_FE_timeLags = map(.x = data, fit = reg4, .f = model_pred),\n           ETime_Space_FE_timeLags_holidayLags = map(.x = data, fit = reg5, .f = model_pred)) %>% \n    gather(Regression, Prediction, -data, -week) %>%\n    mutate(Observed = map(data, pull, Trip_Count),\n           Absolute_Error = map2(Observed, Prediction,  ~ abs(.x - .y)),\n           MAE = map_dbl(Absolute_Error, mean, na.rm = TRUE),\n           sd_AE = map_dbl(Absolute_Error, sd, na.rm = TRUE))\n\nweek_predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 8\n    week data     Regression      Prediction Observed Absolute_Error   MAE sd_AE\n   <dbl> <list>   <chr>           <list>     <list>   <list>         <dbl> <dbl>\n 1    18 <tibble> ATime_FE        <dbl>      <dbl>    <dbl [74,712]> 1.27   2.31\n 2    19 <tibble> ATime_FE        <dbl>      <dbl>    <dbl [95,088]> 1.09   2.01\n 3    18 <tibble> BSpace_FE       <dbl>      <dbl>    <dbl [74,712]> 1.14   2.13\n 4    19 <tibble> BSpace_FE       <dbl>      <dbl>    <dbl [95,088]> 1.03   1.91\n 5    18 <tibble> CTime_Space_FE  <dbl>      <dbl>    <dbl [74,712]> 1.17   1.99\n 6    19 <tibble> CTime_Space_FE  <dbl>      <dbl>    <dbl [95,088]> 1.08   1.77\n 7    18 <tibble> DTime_Space_FE… <dbl>      <dbl>    <dbl [74,712]> 0.889  1.67\n 8    19 <tibble> DTime_Space_FE… <dbl>      <dbl>    <dbl [95,088]> 0.767  1.41\n 9    18 <tibble> ETime_Space_FE… <dbl>      <dbl>    <dbl [74,712]> 0.890  1.67\n10    19 <tibble> ETime_Space_FE… <dbl>      <dbl>    <dbl [95,088]> 0.767  1.41\n```\n\n\n:::\n:::\n\n\n## 5.1. Examine Error Metrics for Accuracy\n\nThe best models - the lag models, are accurate to less than an average of one ride per hour, at a glance, that's pretty alright for overall accuracy.\n\n**Which models perform best - and how would you describe their fit?**\n\n**Why don't the holiday time lags seem to matter?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_predictions %>%\n  dplyr::select(week, Regression, MAE) %>%\n  gather(Variable, MAE, -Regression, -week) %>%\n  ggplot(aes(week, MAE)) + \n    geom_bar(aes(fill = Regression), position = \"dodge\", stat=\"identity\") +\n    scale_fill_manual(values = palette5) +\n    labs(title = \"Mean Absolute Errors by model specification and week\") +\n  plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/plot_errors_by_model-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_predictions %>% \n    mutate(interval60 = map(data, pull, interval60),\n           from_station_id = map(data, pull, from_station_id)) %>%\n    dplyr::select(interval60, from_station_id, Observed, Prediction, Regression) %>%\n    unnest() %>%\n    gather(Variable, Value, -Regression, -interval60, -from_station_id) %>%\n    group_by(Regression, Variable, interval60) %>%\n    summarize(Value = sum(Value)) %>%\n    ggplot(aes(interval60, Value, colour=Variable)) + \n      geom_line(size = 1.1) + \n      facet_wrap(~Regression, ncol=1) +\n      labs(title = \"Predicted/Observed bike share time series\", subtitle = \"Chicago; A test set of 2 weeks\",  x = \"Hour\", y= \"Station Trips\") +\n      plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/error_vs_actual_timeseries -1.png){width=672}\n:::\n:::\n\n\nMoving forward, let's stick with `reg5`, which seems to have the best goodness of fit generally.\n\nWe can look at our mean absolute errors by station - **there seems to be a spatial pattern to our error (what is it?)**, but we need to go a bit further to get at the temporal element of the error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_predictions %>% \n    mutate(interval60 = map(data, pull, interval60),\n           from_station_id = map(data, pull, from_station_id), \n           from_latitude = map(data, pull, from_latitude), \n           from_longitude = map(data, pull, from_longitude)) %>%\n    select(interval60, from_station_id, from_longitude, from_latitude, Observed, Prediction, Regression) %>%\n    unnest() %>%\n  filter(Regression == \"ETime_Space_FE_timeLags_holidayLags\") %>%\n  group_by(from_station_id, from_longitude, from_latitude) %>%\n  summarize(MAE = mean(abs(Observed-Prediction), na.rm = TRUE))%>%\nggplot(.)+\n  geom_sf(data = chicagoCensus, color = \"grey\", fill = \"transparent\")+\n  geom_point(aes(x = from_longitude, y = from_latitude, color = MAE), \n             fill = \"transparent\", alpha = 0.4)+\n  scale_colour_viridis(direction = -1,\n  discrete = FALSE, option = \"D\")+\n  ylim(min(dat_census$from_latitude), max(dat_census$from_latitude))+\n  xlim(min(dat_census$from_longitude), max(dat_census$from_longitude))+\n  labs(title=\"Mean Abs Error, Test Set, Model 5\")+\n  mapTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/errors_by_station-1.png){width=672}\n:::\n:::\n\n\n## 5.2. Space-Time Error Evaluation\n\nIf we plot observed vs. predicted for different times of day during the week and weekend, some patterns begin to emerge. We are certainly underpredicting in general, but **what do we begin to see about some of the outcomes that our model cannot explain?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_predictions %>% \n    mutate(interval60 = map(data, pull, interval60),\n           from_station_id = map(data, pull, from_station_id), \n           from_latitude = map(data, pull, from_latitude), \n           from_longitude = map(data, pull, from_longitude),\n           dotw = map(data, pull, dotw)) %>%\n    select(interval60, from_station_id, from_longitude, \n           from_latitude, Observed, Prediction, Regression,\n           dotw) %>%\n    unnest() %>%\n  filter(Regression == \"ETime_Space_FE_timeLags_holidayLags\")%>%\n  mutate(weekend = ifelse(dotw %in% c(\"Sun\", \"Sat\"), \"Weekend\", \"Weekday\"),\n         time_of_day = case_when(hour(interval60) < 7 | hour(interval60) > 18 ~ \"Overnight\",\n                                 hour(interval60) >= 7 & hour(interval60) < 10 ~ \"AM Rush\",\n                                 hour(interval60) >= 10 & hour(interval60) < 15 ~ \"Mid-Day\",\n                                 hour(interval60) >= 15 & hour(interval60) <= 18 ~ \"PM Rush\"))%>%\n  ggplot()+\n  geom_point(aes(x= Observed, y = Prediction))+\n    geom_smooth(aes(x= Observed, y= Prediction), method = \"lm\", se = FALSE, color = \"red\")+\n    geom_abline(slope = 1, intercept = 0)+\n  facet_grid(time_of_day~weekend)+\n  labs(title=\"Observed vs Predicted\",\n       x=\"Observed trips\", \n       y=\"Predicted trips\")+\n  plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/obs_pred_all-1.png){width=672}\n:::\n:::\n\n\nIs there a spatial pattern to these big errors? Let's look at our errors on a map by weekend/weekday and time of day.\n\nSeems like these are concentrated in certain areas - along the water during weekend afternoons (pleasure rides?), in the Loop (aka Downtown) during afternoon rush hour times.\n\n**What is the implication for rebalancing with these errors - does it matter if they are higher volume locations?**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_predictions %>% \n    mutate(interval60 = map(data, pull, interval60),\n           from_station_id = map(data, pull, from_station_id), \n           from_latitude = map(data, pull, from_latitude), \n           from_longitude = map(data, pull, from_longitude),\n           dotw = map(data, pull, dotw) ) %>%\n    select(interval60, from_station_id, from_longitude, \n           from_latitude, Observed, Prediction, Regression,\n           dotw) %>%\n    unnest() %>%\n  filter(Regression == \"ETime_Space_FE_timeLags_holidayLags\")%>%\n  mutate(weekend = ifelse(dotw %in% c(\"Sun\", \"Sat\"), \"Weekend\", \"Weekday\"),\n         time_of_day = case_when(hour(interval60) < 7 | hour(interval60) > 18 ~ \"Overnight\",\n                                 hour(interval60) >= 7 & hour(interval60) < 10 ~ \"AM Rush\",\n                                 hour(interval60) >= 10 & hour(interval60) < 15 ~ \"Mid-Day\",\n                                 hour(interval60) >= 15 & hour(interval60) <= 18 ~ \"PM Rush\")) %>%\n  group_by(from_station_id, weekend, time_of_day, from_longitude, from_latitude) %>%\n  summarize(MAE = mean(abs(Observed-Prediction), na.rm = TRUE))%>%\n  ggplot(.)+\n  geom_sf(data = chicagoCensus, color = \"grey\", fill = \"transparent\")+\n  geom_point(aes(x = from_longitude, y = from_latitude, color = MAE), \n             fill = \"transparent\", size = 0.5, alpha = 0.4)+\n  scale_colour_viridis(direction = -1,\n  discrete = FALSE, option = \"D\")+\n  ylim(min(dat_census$from_latitude), max(dat_census$from_latitude))+\n  xlim(min(dat_census$from_longitude), max(dat_census$from_longitude))+\n  facet_grid(weekend~time_of_day)+\n  labs(title=\"Mean Absolute Errors, Test Set\")+\n  mapTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/station_summary-1.png){width=672}\n:::\n:::\n\n\nLet's focus on the morning commute, where station locations probably relate to likely users, who seem to be commuting downtown to the loop. How is the model performing on weekday mornings relative to demand for public transportation (e.g. possible user base). We can tell that there are a select few stations that are proving very resistant to our model - they have high income, low transit usage and are <50% minority, demographically.\n\nPro Tip: If you want to look at your nested data sets to figure out what to `pull` from them, you can check out one of the data frames by using matrix notation and calling something like this: `week_predictions$data[1] %>% glimpse()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweek_predictions %>% \n    mutate(interval60 = map(data, pull, interval60),\n           from_station_id = map(data, pull, from_station_id), \n           from_latitude = map(data, pull, from_latitude), \n           from_longitude = map(data, pull, from_longitude),\n           dotw = map(data, pull, dotw),\n           Percent_Taking_Public_Trans = map(data, pull, Percent_Taking_Public_Trans),\n           Med_Inc = map(data, pull, Med_Inc),\n           Percent_White = map(data, pull, Percent_White)) %>%\n    select(interval60, from_station_id, from_longitude, \n           from_latitude, Observed, Prediction, Regression,\n           dotw, Percent_Taking_Public_Trans, Med_Inc, Percent_White) %>%\n    unnest() %>%\n  filter(Regression == \"ETime_Space_FE_timeLags_holidayLags\")%>%\n  mutate(weekend = ifelse(dotw %in% c(\"Sun\", \"Sat\"), \"Weekend\", \"Weekday\"),\n         time_of_day = case_when(hour(interval60) < 7 | hour(interval60) > 18 ~ \"Overnight\",\n                                 hour(interval60) >= 7 & hour(interval60) < 10 ~ \"AM Rush\",\n                                 hour(interval60) >= 10 & hour(interval60) < 15 ~ \"Mid-Day\",\n                                 hour(interval60) >= 15 & hour(interval60) <= 18 ~ \"PM Rush\")) %>%\n  filter(time_of_day == \"AM Rush\") %>%\n  group_by(from_station_id, Percent_Taking_Public_Trans, Med_Inc, Percent_White) %>%\n  summarize(MAE = mean(abs(Observed-Prediction), na.rm = TRUE))%>%\n  gather(-from_station_id, -MAE, key = \"variable\", value = \"value\")%>%\n  ggplot(.)+\n  #geom_sf(data = chicagoCensus, color = \"grey\", fill = \"transparent\")+\n  geom_point(aes(x = value, y = MAE), alpha = 0.4)+\n  geom_smooth(aes(x = value, y = MAE), method = \"lm\", se= FALSE)+\n  facet_wrap(~variable, scales = \"free\")+\n  labs(title=\"Errors as a function of socio-economic variables\",\n       y=\"Mean Absolute Error (Trips)\")+\n  plotTheme\n```\n\n::: {.cell-output-display}\n![](week-11-class-lab_files/figure-html/station_summary2-1.png){width=672}\n:::\n:::\n\n\n## 6.1. Interpreting our predictions\n\nBased on our time-series plots, we can see that we are able to track the time components of demand, but we miss the peaks, and underpredict for periods of high demand. Based on subsequent maps of our errors, we can see that these peaks seem to have some spatial or demographic pattern to them.\n\nSome things to consider at this point:\n\n**From an operations perspective, what is the problem with underpredicting for high demand? Can you think of some of the possible effects of these underpredictions?**\n\n**What are some next steps to try to depress the errors? How can we spatially explore them further to understand where we are predicting poorly? **\n\n**What information can we add to our model, or how might we transform our features? What is it about the stations that are resisting accurate prediction that can be controlled for?**",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}